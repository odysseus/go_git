// Functions that deal with a single Github user. Some of these are direct,
// pass-through implementations of Github API requests, others collect,
// manipulate, and/or summarize the data generated by them
package git

import (
	"fmt"
)

// Pass-through for GET /users/:user
func User(user string, token OAuthToken) map[string]interface{} {
	js := APIRequest(fmt.Sprintf("users/%s", user), 100, token)
	return js[0]
}

// Pass-through for GET /users/:user/repos
func UserRepos(user string, token OAuthToken) []map[string]interface{} {
	return APIRequest(fmt.Sprintf("users/%s/repos", user), 100, token)
}

// Returns the total number of repos for the user
func UserRepoCount(user string, token OAuthToken) int {
	js := User(user, token)
	val := js["public_repos"]
	if fin, ok := val.(float64); ok {
		return int(fin)
	} else {
		panic(fmt.Sprintf("%v Failed to convert to float64", val))
	}
	return -1
}

// Returns a slice of all the repo names for a user
func UserRepoNames(user string, token OAuthToken) []string {
	js := APIRequest(fmt.Sprintf("users/%s/repos", user), 100, token)
	vals := ValuesForKey("name", js)
	return StringifyInterfaceSlice(vals)
}

// The number of bytes written in each language across all of a user's repos
func UserLanguageSummary(user string, token OAuthToken) map[string]int {
	fin := make(map[string]int)
	repos := UserRepoNames(user, token)

	for _, repo := range repos {
		langs := RepoLanguages(user, repo, token)
		for k, v := range langs {
			fin[k] += v
		}
	}

	return fin
}
